<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <!-- Uikit -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://judge.yosupo.jp/public/css/uikit.min.css" />
    <script src="https://judge.yosupo.jp/public/js/uikit.min.js"></script>
    <script src="https://judge.yosupo.jp/public/js/uikit-icons.min.js"></script>
    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css"
        integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js"
        integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js"
        integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <!-- Ace editor-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>

    <style>
        h2 {
            border-bottom:1px solid #CCC;
        }
    </style>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(
                document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false }],
                ignoredTags: [],
            })
            for (e of document.getElementsByClassName("sample-code")) {
                var editor = ace.edit(e);
                editor.setOption("maxLines", "Infinity");
                editor.setReadOnly(true);
                editor.getSession().setMode("ace/mode/c_cpp");                
            }
        });
    </script>
</head><body>
    <div class="uk-navbar-container" uk-navbar>
        <div class="uk-navbar-left">
            <a href="./index.html" class="uk-navbar-item uk-logo">AC Library</a>
        </div>
    </div>
    <section class="uk-section">
        <div class="uk-container">
            <h1>Lazy Segtree</h1>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89">ãƒ¢ãƒã‚¤ãƒ‰</a> $(S, \cdot: S \times S \to S, e \in S)$ã¨ã€$S$ ã‹ã‚‰ $S$ ã¸ã®å†™åƒã®é›†åˆ $F$ ã§ã‚ã£ã¦ã€ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ã‚ˆã†ãªã‚‚ã®ã«ã¤ã„ã¦ä½¿ç”¨ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚</p>
<ul>
<li>$F$ ã¯æ’ç­‰å†™åƒ $\mathrm{id}$ ã‚’å«ã‚€ã€‚ã¤ã¾ã‚Šã€ä»»æ„ã® $x \in S$ ã«å¯¾ã— $\mathrm{id}(x) = x$ ã‚’ã¿ãŸã™ã€‚</li>
<li>$F$ ã¯å†™åƒã®åˆæˆã«ã¤ã„ã¦é–‰ã˜ã¦ã„ã‚‹ã€‚ã¤ã¾ã‚Šã€ä»»æ„ã® $f, g \in F$ ã«å¯¾ã— $f \circ g \in F$ ã§ã‚ã‚‹ã€‚</li>
<li>ä»»æ„ã® $f \in F, x, y \in S$ ã«å¯¾ã— $f(x \cdot y) = f(x) \cdot f(y)$ ã‚’ã¿ãŸã™ã€‚</li>
</ul>
<p>é•·ã• $N$ ã® $S$ ã®é…åˆ—ã«å¯¾ã—ã€</p>
<ul>
<li>åŒºé–“ã®è¦ç´ ã«ä¸€æ‹¬ã§ $F$ ã®è¦ç´  $f$ ã‚’ä½œç”¨($x = f(x)$ )</li>
<li>åŒºé–“ã®è¦ç´ ã®ç·ç©ã®å–å¾—</li>
</ul>
<p>ã‚’ $O(\log N)$ ã§è¡Œã†ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚è©³ç´°ãªè¦ä»¶ã¯ <a href="./appendix.html">Appendix</a> ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</p>
<p>ã¾ãŸã€ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã‚ªãƒ©ã‚¯ãƒ«ã¨ã—ã¦<code>op, e, mapping, composition, id</code>ã‚’ä½¿ç”¨ã—ã¾ã™ãŒã€ã“ã‚Œã‚‰ãŒå®šæ•°æ™‚é–“ã§å‹•ãã‚‚ã®ã¨ä»®å®šã—ãŸã¨ãã®è¨ˆç®—é‡ã‚’è¨˜è¿°ã—ã¾ã™ã€‚ã‚ªãƒ©ã‚¯ãƒ«å†…éƒ¨ã®è¨ˆç®—é‡ãŒ $O(f(n))$ ã§ã‚ã‚‹å ´åˆã¯ã™ã¹ã¦ã®è¨ˆç®—é‡ãŒ $O(f(n))$ å€ã¨ãªã‚Šã¾ã™ã€‚</p>
<h2>ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿</h2>
<pre><code class="cpp">(1) lazy_segtree&lt;S, op, e, F, mapping, composition, id&gt; seg(int n);
(2) lazy_segtree&lt;S, op, e, F, mapping, composition, id&gt; seg(vector&lt;T&gt; v);
</code></pre>

<ul>
<li>ãƒ¢ãƒã‚¤ãƒ‰ã®å‹ <code>S</code></li>
<li>$\cdot: S \times S \to S$ ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•° <code>S op(S a, S b)</code></li>
<li>$e$ ã‚’è¿”ã™é–¢æ•° <code>S e()</code></li>
<li>å†™åƒã®å‹ <code>F</code></li>
<li>$f(x)$ ã‚’è¿”ã™é–¢æ•° <code>S mapping(F f, S x)</code></li>
<li>$f \circ g$ ã‚’è¿”ã™é–¢æ•° <code>F composition(F f, F g)</code></li>
<li>$id$ ã‚’è¿”ã™é–¢æ•° <code>F id()</code></li>
</ul>
<p>ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
è©³ã—ãã¯ã€ä½¿ç”¨ä¾‹ã‚„ <a href="https://atcoder.jp/contests/practice2/editorial">ã“ã¡ã‚‰</a> ã‚‚å‚ç…§ã—ã¦ãã ã•ã„ã€‚</p>
<ul>
<li>(1): é•·ã• <code>n</code> ã®æ•°åˆ— <code>a</code> ã‚’ä½œã‚Šã¾ã™ã€‚åˆæœŸå€¤ã¯å…¨éƒ¨<code>e()</code>ã§ã™ã€‚</li>
<li>(2): é•·ã• <code>n = v.size()</code> ã®æ•°åˆ— <code>a</code> ã‚’ä½œã‚Šã¾ã™ã€‚<code>v</code> ã®å†…å®¹ãŒåˆæœŸå€¤ã¨ãªã‚Šã¾ã™ã€‚</li>
</ul>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li>$0 \leq n \leq 10^8$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(n)$</li>
</ul>
<h2>set</h2>
<pre><code class="cpp">void seg.set(int p, S x)
</code></pre>

<p><code>a[p] = x</code></p>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li>$0 \leq p &lt; n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>get</h2>
<pre><code class="cpp">S seg.get(int p)
</code></pre>

<p><code>a[p]</code> ã‚’è¿”ã—ã¾ã™ã€‚</p>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li>$0 \leq p &lt; n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>prod</h2>
<pre><code class="cpp">S seg.prod(int l, int r)
</code></pre>

<p><code>op(a[l], ..., a[r - 1])</code> ã‚’ã€ãƒ¢ãƒã‚¤ãƒ‰ã®æ€§è³ªã‚’æº€ãŸã—ã¦ã„ã‚‹ã¨ä»®å®šã—ã¦è¨ˆç®—ã—ã¾ã™ã€‚$l = r$ ã®ã¨ãã¯ <code>e()</code> ã‚’è¿”ã—ã¾ã™ã€‚</p>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li>$0 \leq l \leq r \leq n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>all_prod</h2>
<pre><code class="cpp">S seg.all_prod()
</code></pre>

<p><code>op(a[0], ..., a[n-1])</code> ã‚’è¨ˆç®—ã—ã¾ã™ã€‚$n = 0$ ã®ã¨ãã¯ <code>e()</code> ã‚’è¿”ã—ã¾ã™ã€‚</p>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(1)$</li>
</ul>
<h2>apply</h2>
<pre><code class="cpp">(1) void seg.apply(int p, F f)
(2) void seg.apply(int l, int r, F f)
</code></pre>

<ul>
<li>(1) <code>a[p] = f(a[p])</code></li>
<li>(2) <code>i = l..r-1</code>ã«ã¤ã„ã¦<code>a[i] = f(a[i])</code></li>
</ul>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li>(1) $0 \leq p &lt; n$</li>
<li>(2) $0 \leq l \leq r \leq n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>max_right</h2>
<pre><code class="cpp">(1) int seg.max_right&lt;g&gt;(int l)
(2ğŸ’») int seg.max_right&lt;G&gt;(int l, G g)
</code></pre>

<ul>
<li>(1): é–¢æ•° <code>bool g(S x)</code> ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  </li>
<li>(2): <code>S</code>ã‚’å¼•æ•°ã«ã¨ã‚Š<code>bool</code>ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  </li>
</ul>
<p>ä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ <code>r</code> ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚</p>
<ul>
<li><code>r = l</code> ã‚‚ã—ãã¯ <code>g(op(a[l], a[l + 1], ..., a[r - 1])) = true</code></li>
<li><code>r = n</code> ã‚‚ã—ãã¯ <code>g(op(a[l], a[l + 1], ..., a[r])) = false</code></li>
</ul>
<p><code>g</code>ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€<code>g(op(a[l], a[l + 1], ..., a[r - 1])) = true</code> ã¨ãªã‚‹æœ€å¤§ã® <code>r</code>ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚</p>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li><code>g</code>ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)</li>
<li><code>g(e()) = true</code></li>
<li>$0 \leq l \leq n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>min_left</h2>
<pre><code class="cpp">(1) int seg.min_left&lt;g&gt;(int r)
(2ğŸ’») int seg.min_left&lt;G&gt;(int r, G g)
</code></pre>

<ul>
<li>(1): é–¢æ•° <code>bool g(S x)</code> ã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚segtreeã®ä¸Šã§äºŒåˆ†æ¢ç´¢ã‚’ã—ã¾ã™ã€‚  </li>
<li>(2): <code>S</code>ã‚’å¼•æ•°ã«ã¨ã‚Š<code>bool</code>ã‚’è¿”ã™é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚  </li>
</ul>
<p>ä»¥ä¸‹ã®æ¡ä»¶ã‚’ä¸¡æ–¹æº€ãŸã™ <code>l</code> ã‚’(ã„ãšã‚Œã‹ä¸€ã¤)è¿”ã—ã¾ã™ã€‚</p>
<ul>
<li><code>l = r</code> ã‚‚ã—ãã¯ <code>g(op(a[l], a[l + 1], ..., a[r - 1])) = true</code></li>
<li><code>l = 0</code> ã‚‚ã—ãã¯ <code>g(op(a[l - 1], a[l], ..., a[r - 1])) = false</code></li>
</ul>
<p><code>g</code>ãŒå˜èª¿ã ã¨ã™ã‚Œã°ã€<code>g(op(a[l], a[l + 1], ..., a[r - 1])) = true</code> ã¨ãªã‚‹æœ€å°ã® <code>l</code>ã€ã¨è§£é‡ˆã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚</p>
<p><strong>åˆ¶ç´„</strong></p>
<ul>
<li><code>g</code>ã‚’åŒã˜å¼•æ•°ã§å‘¼ã‚“ã æ™‚ã€è¿”ã‚Šå€¤ã¯ç­‰ã—ã„(=å‰¯ä½œç”¨ã¯ãªã„)</li>
<li><code>g(e()) = true</code></li>
<li>$0 \leq r \leq n$</li>
</ul>
<p><strong>è¨ˆç®—é‡</strong></p>
<ul>
<li>$O(\log n)$</li>
</ul>
<h2>ä½¿ç”¨ä¾‹</h2>
<h3>AC code of <a href="https://atcoder.jp/contests/practice2/tasks/practice2_k">https://atcoder.jp/contests/practice2/tasks/practice2_k</a></h3>
<div class="sample-code">#include &lt;atcoder/lazysegtree&gt;
#include &lt;atcoder/modint&gt;
#include &lt;cstdio&gt;

using namespace std;
using namespace atcoder;

using mint = modint998244353;

struct S {
    mint a;
    int size;
};

struct F {
    mint a, b;
};

S op(S l, S r) { return S{l.a + r.a, l.size + r.size}; }

S e() { return S{0, 0}; }

S mapping(F l, S r) { return S{r.a * l.a + r.size * l.b, r.size}; }

F composition(F l, F r) { return F{r.a * l.a, r.b * l.a + l.b}; }

F id() { return F{1, 0}; }

int main() {
    int n, q;
    scanf(&#34;%d %d&#34;, &amp;n, &amp;q);

    vector&lt;S&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        int x;
        scanf(&#34;%d&#34;, &amp;x);
        a[i] = S{x, 1};
    }

    lazy_segtree&lt;S, op, e, F, mapping, composition, id&gt; seg(a);

    for (int i = 0; i &lt; q; i++) {
        int t;
        scanf(&#34;%d&#34;, &amp;t);
        if (t == 0) {
            int l, r;
            int c, d;
            scanf(&#34;%d %d %d %d&#34;, &amp;l, &amp;r, &amp;c, &amp;d);
            seg.apply(l, r, F{c, d});
        } else {
            int l, r;
            scanf(&#34;%d %d&#34;, &amp;l, &amp;r);
            printf(&#34;%d\n&#34;, seg.prod(l, r).a.val());
        }
    }
}
</div>

<h3>AC code of <a href="https://atcoder.jp/contests/practice2/tasks/practice2_l">https://atcoder.jp/contests/practice2/tasks/practice2_l</a></h3>
<div class="sample-code">#include &lt;atcoder/lazysegtree&gt;
#include &lt;atcoder/modint&gt;
#include &lt;cstdio&gt;

using namespace std;
using namespace atcoder;

using mint = modint998244353;

struct S {
    // # of 0 / # of 1 / inversion number
    long long zero, one, inversion;
};

// swapping flag
using F = bool;

S op(S l, S r) {
    return S{
        l.zero + r.zero,
        l.one + r.one,
        l.inversion + r.inversion + l.one * r.zero,
    };
}

S e() { return S{0, 0, 0}; }

S mapping(F l, S r) {
    if (!l) return r;
    // swap
    return S{r.one, r.zero, r.one * r.zero - r.inversion};
}

F composition(F l, F r) { return (l &amp;&amp; !r) || (!l &amp;&amp; r); }

F id() { return false; }

int main() {
    int n, q;
    scanf(&#34;%d %d&#34;, &amp;n, &amp;q);

    vector&lt;S&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        int x;
        scanf(&#34;%d&#34;, &amp;x);
        if (x == 0)
            a[i] = S{1, 0, 0};
        else
            a[i] = S{0, 1, 0};
    }

    lazy_segtree&lt;S, op, e, F, mapping, composition, id&gt; seg(a);
    for (int i = 0; i &lt; q; i++) {
        int t, l, r;
        scanf(&#34;%d %d %d&#34;, &amp;t, &amp;l, &amp;r);
        l--;
        if (t == 1) {
            seg.apply(l, r, true);
        } else {
            printf(&#34;%lld\n&#34;, seg.prod(l, r).inversion);
        }
    }
}
</div>
        </div>
    </section>
</body>

</html>
